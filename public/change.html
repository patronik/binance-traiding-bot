<!DOCTYPE html>
<html>
  <head>
    <style>
      table {
        border-collapse: collapse;
        width: 100%;
      }
      th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
      }
      th {
        background-color: #f2f2f2;
      }      
      #admin-panel label {
        padding: 0px 10px 0px 10px;
      }
    </style>
  </head>
<body>
  <div id="admin-panel">       
    <label>
      Buy for <input type="number" id="USDTPercent" style="width: 50px;" step="10" max="100" min="10" value="100">% of USDT        
    </label>
    <label>
      Buy for fixed <input type="number" id="fixedUSDT" style="width: 50px;" value="1000"> USDT       
    </label>
    <label for="updateRate">
      Update rate
      <select id="updateRate">
        <option value="1">1</option>
        <option value="5">5</option>
        <option value="10">10</option>
        <option value="15">15</option>
        <option value="30">30</option>
        <option value="60">60</option>
      </select> seconds.
    </label>
    <label>
      USDT bal. <span id="usdt-bal"></span>
    </label> 
  </div>  
  <div id="hiddenContainer" style="display:none;">
  </div>
  <div>
    <table id="renderTable">      
    </table>  
  </div>
</body>
</html>
<script>
  const feePercent = 0.2;  
  function subtractPercentage(amount, percentage) {
    const reduction = (amount * percentage) / 100;
    const newAmount  = amount - reduction;
    return newAmount;
  }

  async function getSymbolPrecision(symbol) {
    const response = await fetch(`/precision/${symbol}`);
    const data = await response.json(); 
    return {
      qty: parseFloat(data.quantityPrecision).toString().split('.')[1].length,
      price: parseFloat(data.pricePrecision).toString().split('.')[1].length,
    };
  }

  async function sellAmount(symbol) {
    let amount = parseFloat(document.getElementById(`f-bal-${symbol}`).textContent);
    if (isNaN(amount)) {
      alert('Invalid asset amount.');  
      return;
    }

    const assetPrice = parseFloat(document.getElementById(`price-${symbol}`).textContent);
    if (isNaN(assetPrice)) {
      alert(`Invalid asset price ${assetPrice}.`);  
      return;
    }     
        
    amount = subtractPercentage(amount, feePercent);    
    
    const precision = await getSymbolPrecision(symbol);
    amount = amount.toFixed(precision.qty);

    const confirmation = confirm(`Are you sure you want to sell ${amount} of ${symbol} (${assetPrice * amount} USDT)?`);

    if (confirmation) {
      try {
        const response = await fetch('/sell-symbol', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ amount, symbol })
        });
        const data = await response.json();
        alert(`Sell Response: ${JSON.stringify(data)}`);
      } catch (error) {
        alert('Error placing sell order:', error);
      }
    }
  }

  async function buyForFixedUSDT(symbol) {
    const fixedUSDT = parseFloat(document.getElementById(`fixedUSDT`).value);
    if (isNaN(fixedUSDT)) {
      alert(`Invalid fixed USDT amount ${fixedUSDT}.`);  
      return;
    }    

    const assetPrice = parseFloat(document.getElementById(`price-${symbol}`).textContent);
    if (isNaN(assetPrice)) {
      alert(`Invalid asset price ${assetPrice}.`);  
      return;
    }    
        
    let amount = parseFloat(fixedUSDT / assetPrice);
    if (isNaN(amount)) {
      alert(`Invalid amount to buy ${amount}.`);  
      return;
    }    

    amount = subtractPercentage(amount, feePercent);
    
    const precision = await getSymbolPrecision(symbol);
    amount = amount.toFixed(precision.qty);

    const confirmation = confirm(`Are you sure you want to buy ${amount} of ${symbol} (for ${fixedUSDT} USDT)?`);

    if (confirmation) {
      try {
        const response = await fetch('/buy-symbol', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ amount, symbol })
        });
        const data = await response.json();
        alert(`Buy Response: ${JSON.stringify(data)}`);
      } catch (error) {
        alert('Error placing buy order:', error);
      }
    }
  }

  async function buyUSDTPercent(symbol) {
    const USDTPercent = parseFloat(document.getElementById(`USDTPercent`).value);
    if (isNaN(USDTPercent)) {
      alert(`Invalid buy percent ${USDTPercent}.`); 
      return;
    }

    const USDTBal = parseFloat(document.getElementById(`usdt-bal`).textContent);
    if (isNaN(USDTBal)) {
      alert(`Invalid USDT balance ${USDTBal}.`);  
      return;
    }    

    const assetPrice = parseFloat(document.getElementById(`price-${symbol}`).textContent);
    if (isNaN(assetPrice)) {
      alert(`Invalid asset price ${assetPrice}.`);  
      return;
    }    
        
    let amount = parseFloat((USDTBal / 100 * USDTPercent) / assetPrice);
    if (isNaN(amount)) {
      alert(`Invalid amount to buy ${amount}.`);  
      return;
    }    
    
    amount = subtractPercentage(amount, feePercent);

    const precision = await getSymbolPrecision(symbol);
    amount = amount.toFixed(precision.qty);

    const confirmation = confirm(`Are you sure you want to buy ${amount} of ${symbol} (for ${USDTPercent}% USDT)?`);

    if (confirmation) {
      try {
        const response = await fetch('/buy-symbol', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ amount, symbol })
        });
        const data = await response.json();
        alert(`Buy Response: ${JSON.stringify(data)}`);
      } catch (error) {
        alert('Error placing buy order:', error);
      }
    }
  }
  
  const runMonitoring = async () => {
    const symbols = await (async () => { 
      const response = await fetch('/change-symbols', {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' },
      });
      return await response.json();
  })();

  // Define the symbols to fetch
  const apiUrl = `https://api.binance.com/api/v3/ticker/price`;

  // Initialize data storage
  const priceHistory = {};
  symbols.forEach(symbol => priceHistory[symbol] = []);

  // Create table structure in HTML
  document.getElementById("hiddenContainer").innerHTML = `          
    <table id="priceTable">
      <thead>
        <tr>
          <th>Symbol</th>
          <th>Current Price (USDT)</th>
          <th>F bal.</th>
          <th>F bal. in USDT</th>
          <th>O bal.</th>          
          <th>O bal. in USDT</th>
          <th>Buy percent of USDT.</th>
          <th>Buy for fixed USDT.</th>
          <th>Sell all.</th>
          <th data-sort="number">Change (1 minute %)</th>
          <th data-sort="number">Change (3 minutes %)</th>
          <th data-sort="number">Change (5 minutes %)</th>
          <th data-sort="number">Change (15 minutes%)</th>
          <th data-sort="number">Change (30 minutes%)</th>
          <th data-sort="number">Change (60 minutes%)</th>
        </tr>
      </thead>
      <tbody>
        ${symbols.map(symbol => `
          <tr id="row-${symbol}">
            <td><a href="https://www.binance.com/uk-UA/trade/${symbol.replace('USDT', '_USDT')}?_from=markets&type=spot" target="_blank">${symbol}</a></td>
            <td id="price-${symbol}">--</td>
            <th id="f-bal-${symbol}"></th>
            <th id="f-bal-usdt-${symbol}"></th>
            <th id="o-bal-${symbol}"></th>            
            <th id="o-bal-usdt-${symbol}"></th>
            <th><input type="button" value="Buy for %" onclick="buyUSDTPercent('${symbol}');" /></th>
            <th><input type="button" value="Buy for fixed." onclick="buyForFixedUSDT('${symbol}');" /></th>
            <th><input type="button" value="Sell all" onclick="sellAmount('${symbol}');" /></th>
            <td id="change-${60}-${symbol}">--</td>
            <td id="change-${60 * 3}-${symbol}">--</td>
            <td id="change-${60 * 5}-${symbol}">--</td>
            <td id="change-${60 * 15}-${symbol}">--</td>
            <td id="change-${60 * 30}-${symbol}">--</td>
            <td id="change-${60 * 60}-${symbol}">--</td>
          </tr>
        `).join('')}
      </tbody>
    </table>
  `;

  const sortTable = () => {
    const table = document.getElementById("priceTable");
    const tbody = table.querySelector("tbody");
    const rows = Array.from(tbody.rows);
    const sortColumnIndex = 9;

    // Analyze and style cells before sorting
    rows.forEach(row => {
      for (let i = sortColumnIndex; i <= 20; i++) {
        if(typeof row.cells[i] === 'undefined') {
            continue;
        }
        const cell = row.cells[i];
        if (cell) {
            const value = parseFloat(cell.textContent.trim());
            if (!isNaN(value)) {
                if (value > 0) {
                    cell.style.backgroundColor = "green";
                } else if (value < 0) {
                    cell.style.backgroundColor = "red";
                } else {
                    cell.style.backgroundColor = "grey";
                }
            } else {
                // Clear background for non-numeric values
                cell.style.backgroundColor = ""; 
            }
        }
      }
    });

    // Sort the rows
    rows.sort((rowA, rowB) => {
        const changeA = parseFloat(rowA.cells[sortColumnIndex].textContent.trim());
        const changeB = parseFloat(rowB.cells[sortColumnIndex].textContent.trim());
        return changeB - changeA; // Descending order
    });

    // Reorder rows in the table
    rows.forEach(row => tbody.appendChild(row));
  };

  const updateData = () => {
    let updateRate = parseInt(document.getElementById("updateRate").value, 10);
    if (Math.round((new Date()).getTime() / 1000) % updateRate == 0) {
      document.getElementById("renderTable").innerHTML
       = document.getElementById("priceTable").innerHTML;
    }  
  };

  function updateChange(symbol, seconds) {
    // Update the price history for the last minute
    if (priceHistory[symbol].length >= seconds) {
      // Calculate percentage change
      const priceChange = (
        (priceHistory[symbol][priceHistory[symbol].length - 1] - priceHistory[symbol][priceHistory[symbol].length - seconds]) 
        / priceHistory[symbol][priceHistory[symbol].length - seconds] * 100
      ).toFixed(2);
      document.getElementById(`change-${seconds}-${symbol}`).textContent = `${priceChange}`;
    } else {
      document.getElementById(`change-${seconds}-${symbol}`).textContent = `Collecting ... (${priceHistory[symbol].length})`;
    }  
  }

  async function updateBalances() {
    const response = await fetch('/balances');
    const data = await response.json(); 

    Object.entries(data.balances).forEach(([symbol, balances]) => {
      if (document.getElementById(`f-bal-${symbol}`)) {
        document.getElementById(`f-bal-${symbol}`).textContent 
        = balances.freeBalance;
      }      

      if (document.getElementById(`o-bal-${symbol}`)) {
        document.getElementById(`o-bal-${symbol}`).textContent 
        = balances.onOrderBalance;
      }      

      if (document.getElementById(`f-bal-usdt-${symbol}`)) {
        document.getElementById(`f-bal-usdt-${symbol}`).textContent 
        = balances.freeInUSDT;
      }      

      if (document.getElementById(`o-bal-usdt-${symbol}`)) {
        document.getElementById(`o-bal-usdt-${symbol}`).textContent 
        = balances.onOrderInUSDT;
      }      

      if (symbol == 'USDTUSDT') {
        document.getElementById(`usdt-bal`).textContent 
        = parseFloat(balances.freeBalance).toFixed(2);
      }
    });
  }


  // Fetch and update prices every second
  setInterval(async () => {
    try {    
      const response = await fetch(apiUrl);
      let data = await response.json();      

      data.filter(i => symbols.includes(i.symbol)).forEach(item => {
        const { symbol, price } = item;
        const currentPrice = parseFloat(price);
        
        // Add price to history
        priceHistory[symbol].push(currentPrice);

        // Update the table
        document.getElementById(`price-${symbol}`).textContent = currentPrice.toFixed(8);

        updateChange(symbol, 60);
        updateChange(symbol, 60 * 3);
        updateChange(symbol, 60 * 5);
        updateChange(symbol, 60 * 15);
        updateChange(symbol, 60 * 30);
        updateChange(symbol, 60 * 60);
        
        if (priceHistory[symbol].length >= 60) {
          sortTable();  
          updateData();          
        }

        if (priceHistory[symbol].length >= 60 * 60) {
          priceHistory[symbol].shift();
        }        
      });     
      await updateBalances();
    } catch (error) {
      console.error('Error fetching data:', error);
    }
  }, 1000);
};

runMonitoring();

</script>
