<!DOCTYPE html>
<html>
  <head>
    <style>
      table {
        border-collapse: collapse;
        width: 100%;
      }
      th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
      }
      th {
        background-color: #f2f2f2;
      }
    </style>
  </head>
<body>
  <div>
    <label for="updateRate">
      Update data every 
      <select id="updateRate">
        <option value="1">1</option>
        <option value="5">5</option>
        <option value="10">10</option>
        <option value="15">15</option>
        <option value="30">30</option>
        <option value="60">60</option>
      </select> seconds.
    </label>
  </div>  
  <div id="hiddenContainer" style="display:none;">
  </div>
  <div>
    <table id="renderTable">      
    </table>  
  </div>
</body>
</html>
<script>
const runMonitoring = async () => {
  const symbols = await (async () => { 
    const response = await fetch('/change-symbols', {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
    });
    return await response.json();
  })();

  // Define the symbols to fetch
  const apiUrl = `https://api.binance.com/api/v3/ticker/price`;

  // Initialize data storage
  const priceHistory = {};
  symbols.forEach(symbol => priceHistory[symbol] = []);

  // Create table structure in HTML
  document.getElementById("hiddenContainer").innerHTML = `          
    <table id="priceTable">
      <thead>
        <tr>
          <th>Symbol</th>
          <th>Current Price (USDT)</th>
          <th data-sort="number">Change (1 minute %)</th>
          <th data-sort="number">Change (3 minutes %)</th>
          <th data-sort="number">Change (5 minutes %)</th>
          <th data-sort="number">Change (15 minutes%)</th>
          <th data-sort="number">Change (30 minutes%)</th>
          <th data-sort="number">Change (60 minutes%)</th>
        </tr>
      </thead>
      <tbody>
        ${symbols.map(symbol => `
          <tr id="row-${symbol}">
            <td><a href="https://www.binance.com/uk-UA/trade/${symbol.replace('USDT', '_USDT')}?_from=markets&type=spot" target="_blank">${symbol}</a></td>
            <td id="price-${symbol}">--</td>
            <td id="change-${60}-${symbol}">--</td>
            <td id="change-${60 * 3}-${symbol}">--</td>
            <td id="change-${60 * 5}-${symbol}">--</td>
            <td id="change-${60 * 15}-${symbol}">--</td>
            <td id="change-${60 * 30}-${symbol}">--</td>
            <td id="change-${60 * 60}-${symbol}">--</td>
          </tr>
        `).join('')}
      </tbody>
    </table>
  `;

  const sortTable = () => {
    const table = document.getElementById("priceTable");
    const tbody = table.querySelector("tbody");
    const rows = Array.from(tbody.rows);

    // Analyze and style cells before sorting
    rows.forEach(row => {
      for (let i = 2; i <= 20; i++) {
        if(typeof row.cells[i] === 'undefined') {
            continue;
        }
        const cell = row.cells[i];
        if (cell) {
            const value = parseFloat(cell.textContent.trim());
            if (!isNaN(value)) {
                if (value > 0) {
                    cell.style.backgroundColor = "green";
                } else if (value < 0) {
                    cell.style.backgroundColor = "red";
                } else {
                    cell.style.backgroundColor = "grey";
                }
            } else {
                // Clear background for non-numeric values
                cell.style.backgroundColor = ""; 
            }
        }
      }
    });

    // Sort the rows
    rows.sort((rowA, rowB) => {
        const changeA = parseFloat(rowA.cells[2].textContent.trim());
        const changeB = parseFloat(rowB.cells[2].textContent.trim());
        return changeB - changeA; // Descending order
    });

    // Reorder rows in the table
    rows.forEach(row => tbody.appendChild(row));
  };

  const updateData = () => {
    let updateRate = parseInt(document.getElementById("updateRate").value, 10);
    if (Math.round((new Date()).getTime() / 1000) % updateRate == 0) {
      document.getElementById("renderTable").innerHTML
       = document.getElementById("priceTable").innerHTML;
    }  
  };


  // Fetch and update prices every second
  setInterval(async () => {
    try {
      function updateChange(symbol, seconds) {
        // Update the price history for the last minute
        if (priceHistory[symbol].length >= seconds) {
          // Calculate percentage change
          const priceChange = (
            (priceHistory[symbol][priceHistory[symbol].length - 1] - priceHistory[symbol][priceHistory[symbol].length - seconds]) 
            / priceHistory[symbol][priceHistory[symbol].length - seconds] * 100
          ).toFixed(2);
          document.getElementById(`change-${seconds}-${symbol}`).textContent = `${priceChange}`;
        } else {
          document.getElementById(`change-${seconds}-${symbol}`).textContent = `Collecting data ... (${priceHistory[symbol].length})`;
        }  
      }

      const response = await fetch(apiUrl);
      let data = await response.json();      

      data.filter(i => symbols.includes(i.symbol)).forEach(item => {
        const { symbol, price } = item;
        const currentPrice = parseFloat(price);
        
        // Add price to history
        priceHistory[symbol].push(currentPrice);

        // Update the table
        document.getElementById(`price-${symbol}`).textContent = currentPrice.toFixed(8);

        updateChange(symbol, 60);
        updateChange(symbol, 60 * 3);
        updateChange(symbol, 60 * 5);
        updateChange(symbol, 60 * 15);
        updateChange(symbol, 60 * 30);
        updateChange(symbol, 60 * 60);
        
        if (priceHistory[symbol].length >= 60) {
          sortTable();  
          updateData();          
        }

        if (priceHistory[symbol].length >= 60 * 60) {
          priceHistory[symbol].shift();
        }        
      });
    } catch (error) {
      console.error('Error fetching data:', error);
    }
  }, 1000);
};

runMonitoring();

</script>
